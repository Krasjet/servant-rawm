{-# LANGUAGE OverloadedStrings #-}

module Main where

import Data.ByteString.Lazy (ByteString)
import qualified Data.ByteString.Lazy as LBS
import Data.Monoid ((<>))
import Data.Proxy (Proxy(Proxy))
import Network.HTTP.Client (Response, defaultManagerSettings, newManager, responseBody)
import Network.HTTP.Media (MediaType)
import Network.HTTP.Types (Header, Method, methodGet)
import Servant.API ((:<|>)((:<|>)))
import Servant.Client
       (BaseUrl(BaseUrl), ClientEnv(ClientEnv), ClientM, Scheme(Http),
        client, runClientM)
import Servant.Common.Req (Req, appendToPath)
import Servant.RawM ()

import Api (Api, port)

-----------------------------------------
-- Clients generated by servant-client --
-----------------------------------------

-- We generate the client functions just like normal.  Note that when we use
-- 'Throws' or 'NoThrow', the client functions get generated with the
-- 'Envelope' type.

otherEndpoint1 :: ClientM Int
getFile' :: Method -> (Req -> Req) -> ClientM (Int, ByteString, MediaType, [Header], Response ByteString)
otherEndpoint2 :: ClientM Int
otherEndpoint1 :<|> getFile' :<|> otherEndpoint2 = client (Proxy :: Proxy Api)

getFile :: String -> ClientM ByteString
getFile filePath = do
  (_, _, _, _, resp) <- getFile' methodGet $ \req -> appendToPath filePath req
  pure $ responseBody resp

----------
-- Main --
----------

main :: IO ()
main = do
  manager <- newManager defaultManagerSettings
  let clientEnv = ClientEnv manager baseUrl
  eitherRes <- runClientM (getFile "foo.txt") clientEnv
  case eitherRes of
    Left servantErr -> putStrLn $ "Got a ServantErr: " <> show servantErr
    Right fileContents -> do
      putStrLn "Successfully got file ./example/files/foo.txt:\n"
      LBS.putStr fileContents

baseUrl :: BaseUrl
baseUrl = BaseUrl Http "localhost" port ""
